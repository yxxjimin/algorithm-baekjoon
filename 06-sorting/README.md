# 06. 정렬

> [!NOTE]
> 정렬되지 않은 데이터에서 특정 값을 찾는 것은 $O(N)$이지만 정렬된 데이터에서는 $O(\log N)$이다.

## 이론
정렬 알고리즘은 시간 복잡도, 안정성, 제자리 여부(Inplace) 등 여러 기준에 따라 분류할 수 있지만 비교 여부를 기준으로 분류해보자.

### 비교 정렬 알고리즘 (Comparison Sort)
#### 선택 정렬 (Selection Sort)
- 배열을 순회하면서 가장 작은 값을 선택하여 맨 앞에 배치하고, 두 번째로 작은 값을 또 순회를 통해 선택하여 그 다음에 배치하는 방식이다.
- 시간 복잡도는 $O(N^2)$이다.
    - 총 $N + (N-1) + (N-2) + ... + 2$ 번의 비교를 수행하기 때문이다.
- Stability: ❌ / Inplace: ✅

#### 삽입 정렬 (Insertion Sort)
- 배열에서 $i - 1$ 번째 값까지 정렬되어 있을 때, $i$ 번째 값을 적절한 위치에 삽입하여 정렬하는 방식이다.
- 시간 복잡도는 $O(N^2)$이다.
    - 최악의 경우 $1 + 2 + ... + (N-1) = O(N^2)$ 번의 비교를 수행한다. (역정렬된 배열)
    - 최선의 경우 $1 + 1 + ... + 1 = O(N)$ 번의 비교를 수행한다. (완전 정렬된 배열)
- 따라서 데이터가 *거의 정렬되어 있는 상황*에서 매우 유리하다.
- Stability: ✅ / Inplace: ✅

#### 퀵 정렬 (Quicksort)
- 배열을 두 부분으로 분할하여 피벗(pivot)보다 작은 값은 왼쪽 배열로, 큰 값은 오른쪽 배열로 보낸다.
    - 분할된 두 배열에 대해서도 각각 피벗을 설정하여 동일한 과정을 수행한다.
    - 더 이상 분할할 수 없을 때까지, 즉 분할된 배열의 길이가 1이 될 때 까지 반복한다.
- 전형적인 분할 정복(Divide-and-conquer) 알고리즘이므로 재귀함수로 구현할 수 있다.
    - 배열의 길이가 1이 될 때를 종료 조건으로 설정한다.
    - 또다른 분할 정복 알고리즘으로는 병합 정렬(Merge sort)이 있다.
- 피벗 설정 및 분할 방식에는 여러 가지가 있지만 주로 호어(Hoare) 방식을 사용한다.
    - 첫 번째 데이터를 피벗으로 설정한다.
    - 왼쪽에서 출발하여 피벗보다 큰 값을, 오른쪽에서 순회하면서 피벗보다 작은 값을 찾아 둘을 스왑한다.
- 평균적인 시간 복잡도는 $O(N \log N)$이다.
    - 호어 방식에서는 최악의 경우 (정렬된 배열) $O(N^2)$만큼 걸릴 수도 있다.
        - 분할 횟수(혹은 recursion depth)가 $N$이 되기 때문이다.
- Stability: ❌ / Inplace: ✅

### 非 비교 정렬 알고리즘 (Non-comparison Sort)
#### 계수 정렬 (Counting Sort)
- 배열 내에서 특정 데이터 값의 개수를 세는 방식으로 데이터를 정렬한다.
- 특정 조건들을 충족시켜야 사용할 수 있지만 속도 자체는 매우 빠르다.
    - 개수를 기록할 배열을 만들어야 하므로 정수 값에만 사용할 수 있다.
    - 데이터의 범위가 좁고 반복되는 값이 많을 때 유리하다.
- 데이터의 개수를 $N$, 범위를 $K$라고 할 때 시간 복잡도는 $O(N + K)$이다.

### 파이썬 표준 정렬 라이브러리
- [파이썬 공식 문서 — 정렬 HOW TO](https://docs.python.org/ko/3/howto/sorting.html)
- 파이썬은 기본 정렬 라이브러리인 `sorted()`를 제공한다.
    - 시간 복잡도는 최악의 경우에도 $O(N \log N)$을 보장하며 모든 이터러블을 정렬할 수 있다.
    - 안정성을 보장한다[^1].
    - 정렬된 데이터를 리스트로 반환한다.
- 혹은 리스트에 `sort()` 메소드를 호출할 수도 있다.
    - 새 리스트를 반환하지 않고 호출한 리스트에 직접 정렬한다.
- 기본적으로 `<` 연산을 통해 비교를 수행한다.
    - `key` 매개변수에 함수를 넘겨줄 수 있다.
        - 이 함수는 각 데이터에서 비교(`<`)를 수행할 키(비교 기준)를 추출하는 데에 사용된다.

```python
# Extract a comparison key from each element
list.sort(key=lambda x: len(str(x)))
list.sort(key=str.lower)
```

- 아니면 `cmp_to_key`를 사용하여 직접 비교 함수를 정의할 수도 있다[^2].
    - `a < b`이면 `my_cmp(a, b)`가 음수 값을 반환한다 (값 크기 자체는 중요하지 않음).
    - `a == b`이면 `my_cmp(a, b)`가 0을 반환한다.
    - `a > b`이면 `my_cmp(a, b)`가 양수 값을 반환한다.

```python
# Comparator function
def my_cmp(a, b):
    return ...

from functools import cmp_to_key
list.sort(key=cmp_to_key(my_cmp))
```

[^1]: https://docs.python.org/ko/3/howto/sorting.html#sort-stability-and-complex-sorts
[^2]: https://docs.python.org/3/library/functools.html#functools.cmp_to_key