# 07. 다이나믹 프로그래밍

> [!NOTE]
> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘

## 이론
### 다이나믹 프로그래밍
- 점화식에 따라 수열을 구하는 과정은 재귀 함수를 사용하여 쉽게 구현할 수 있다.
    - 점화식의 형태에 따라 다르지만 보통 시간 복잡도가 $O(2^N)$이다.
    - 문제를 부분 문제로 나누어서 해결한다는 점에서 분할 정복과 유사하다고도 할 수 있다.
        - 다만 분할 정복에서는 부분 문제들이 독립적이지만(disjoint) 피보나치 수열과 같은 점화식에서는 부분 문제들이 중복되는 경우가 많다(overlapping).
- 중복되는 부분 문제를 단 한 번만 처리할 수 있는 방법은 없을까?
    - *메모이제이션(Memoization)* — 한 번 구현한 결과를 메모리에 기록(메모)해놓으면 된다.
        - 동일한 부분 문제가 등장하면 메모해 놓은 정답을 그대로 가져와서 사용하면 된다.
    - 메모이제이션으로 구현하면 시간 복잡도가 $O(N)$으로 줄어든다.
        - 다만 이에 대한 trade-off로 부가적인 메모리 공간(메모해놓을 공간)이 필요하다.

### 탑다운, 바텀업
다이나믹 프로그래밍은 크게 **탑다운** 방식과 **바텀업** 방식이 있다.
- 탑다운(하향식) - 재귀 + 메모이제이션
- 바텀업(상향식) - 아래에서부터 위로 순차적으로 답을 구해나가는 방식

다이나믹 프로그래밍은 일반적으로 최적화 문제에 적용할 수 있디. 다이나믹 프로그래밍을 적용할 때는 아래의 4단게를 따른다.

1. 최적해(optimal solution)의 구조의 특징을 파악한다.
    - 부분 문제의 최적해로부터 전체 문제의 최적해를 구할 수 있음을 보인다.
        - *최적 부분 구조(Optimal substructure)*
2. 최적해의 값(value)을 재귀적으로 정의해본다.
    - 부분 문제를 사용하여 점화식을 세운다. 
3. 최적해의 값을 바텁업으로 계산한다.
4. 계산한 정보들(value)로부터 최적해를 구성한다.

### 최적 부분 구조
- *최적 부분 구조(Optimal substructure)* — 전체 문제의 최적해가 부분 문제의 최적해를 포함하고 있는 구조
- 최적 부분 구조를 가진다는 것은 DP를 적용할 수 있는 단서가 된다.
    - 어떤 문제들은 DP가 아니라 그리디를 적용할 수도 있다.
